mod IMP-CONFIGURATIONS-SMALLSTEP is including IMP-DESUGARED-SYNTAX + STATE .

*** <new> Include the module BUFFER as well
  including BUFFER .
*** </new>

*** <new> Added two new configurations for abrupt termination
  op <`error`,_,_> : State Buffer -> Configuration .             *** generated by division by zero
  op <`halting`,_,_,_> : State Buffer Buffer -> Configuration .
  ---op halt`; : -> Stmt .
*** </new>

  sorts Configuration ExtendedConfiguration .
  subsort Configuration < ExtendedConfiguration .

  op <_,_,_> : AExp State Buffer -> Configuration .
  op <_,_,_> : Int State Buffer -> Configuration .
  op <_,_,_> : BExp State Buffer -> Configuration .
  op <_,_,_> : Bool State Buffer -> Configuration .
  ---- op <_> : Pgm -> Configuration . --- TODO
  op <_,_,_,_> : Stmt State Buffer Buffer -> Configuration . --- TODO
  op o_ : Configuration -> ExtendedConfiguration [prec 80] .   --- one step
  op *_ : Configuration -> ExtendedConfiguration [prec 80] .   --- all steps
  var Cfg Cfg' : Configuration .
 crl * Cfg => * Cfg' if o Cfg => Cfg' .
endm

mod IMP-SEMANTICS-SMALLSTEP is including IMP-CONFIGURATIONS-SMALLSTEP .
  var X : Id .  var Sigma Sigma' : State .  var I I1 I2 : Int .
  var A A' A1 A1' A2 A2' : AExp .  var B B' B1 B1' B2 : BExp .
  var S S' S1 S1' S2 S2' : Stmt .  var P : Pgm .
  var OmegaIn OmegaIn' OmegaOut OmegaOut' : Buffer .

 crl o < X,Sigma,OmegaIn > => < Sigma(X),Sigma,OmegaIn > if Sigma(X) =/=Bool undefined .

--- Addition
crl o < A1 + A2,Sigma,OmegaIn > => < A1' + A2,Sigma',OmegaIn' > if o < A1,Sigma,OmegaIn > => < A1',Sigma',OmegaIn' > .
crl o < A1 + A2,Sigma,OmegaIn > => < error ,Sigma' , OmegaIn' > if o < A1,Sigma,OmegaIn > => < error ,Sigma',OmegaIn' > .
crl o < A1 + A2,Sigma,OmegaIn > => < A1 + A2',Sigma',OmegaIn' > if o < A2,Sigma,OmegaIn > => < A2',Sigma',OmegaIn' > .
crl o < A1 + A2,Sigma,OmegaIn > => < error ,Sigma',OmegaIn' > if o < A2,Sigma,OmegaIn > => < error ,Sigma',OmegaIn' > .
 rl o < I1 + I2,Sigma,OmegaIn > => < I1 +Int I2,Sigma,OmegaIn > .

crl o < A1 / A2,Sigma,OmegaIn > => < A1' / A2,Sigma',OmegaIn' > if o < A1,Sigma,OmegaIn > => < A1',Sigma',OmegaIn' > .
crl o < A1 / A2,Sigma,OmegaIn > => < error ,Sigma',OmegaIn' > if o < A1,Sigma,OmegaIn > => < error ,Sigma',OmegaIn' > .
crl o < A1 / A2,Sigma,OmegaIn > => < A1 / A2',Sigma',OmegaIn' > if o < A2,Sigma,OmegaIn > => < A2',Sigma',OmegaIn' > .
crl o < A1 / A2,Sigma,OmegaIn > => < error ,Sigma',OmegaIn' > if o < A2,Sigma,OmegaIn > => < error ,Sigma',OmegaIn' > .
crl o < I1 / I2,Sigma,OmegaIn > => < I1 /Int I2,Sigma,OmegaIn > if I2 =/=Bool 0 .
 rl o < A1 / 0,Sigma,OmegaIn > => < error ,Sigma,OmegaIn > .
 rl o < I1 / 0,Sigma,OmegaIn > => < error ,Sigma,OmegaIn > .

crl o < A1 <= A2,Sigma,OmegaIn > => < A1' <= A2,Sigma',OmegaIn' > if o < A1,Sigma,OmegaIn > => < A1',Sigma',OmegaIn' > .
crl o < A1 <= A2,Sigma,OmegaIn > => < error ,Sigma',OmegaIn' > if o < A1,Sigma,OmegaIn > => < error ,Sigma',OmegaIn' > .
crl o < I1 <= A2,Sigma,OmegaIn > => < I1 <= A2',Sigma',OmegaIn' > if o < A2,Sigma,OmegaIn > => < A2',Sigma',OmegaIn' > .
crl o < I1 <= A2,Sigma,OmegaIn > => < error ,Sigma',OmegaIn' > if o < A2,Sigma,OmegaIn > => < error ,Sigma',OmegaIn' > .
 rl o < I1 <= I2,Sigma,OmegaIn > => < I1 <=Int I2,Sigma,OmegaIn > .

crl o < ! B,Sigma,OmegaIn > => < ! B',Sigma',OmegaIn' > if o < B,Sigma,OmegaIn > => < B',Sigma',OmegaIn' > .
crl o < ! B,Sigma,OmegaIn > => < error ,Sigma',OmegaIn' > if o < B,Sigma,OmegaIn > => < error ,Sigma',OmegaIn' > .
 rl o < !  true,Sigma,OmegaIn > => < false,Sigma,OmegaIn > .
 rl o < ! false,Sigma,OmegaIn > => <  true,Sigma,OmegaIn > .

crl o < B1 && B2,Sigma,OmegaIn > => < B1' && B2,Sigma',OmegaIn' > if o < B1,Sigma,OmegaIn > => < B1',Sigma',OmegaIn' > .
crl o < B1 && B2,Sigma,OmegaIn > => < error ,Sigma',OmegaIn' > if o < B1,Sigma,OmegaIn > => < error ,Sigma',OmegaIn' > .
 rl o < false && B2,Sigma,OmegaIn > => < false,Sigma,OmegaIn > .
 rl o <  true && B2,Sigma,OmegaIn > => < B2,Sigma,OmegaIn > .
crl o <  true && B2,Sigma,OmegaIn > => < error ,Sigma',OmegaIn' > if < B2,Sigma,OmegaIn > => < error ,Sigma',OmegaIn' >  .

*** <new> Add both input buffer and output buffer to all statement configurations below, and propagate them properly
 rl o < halt ; , Sigma,OmegaIn,OmegaOut > => < halting,Sigma,OmegaIn,OmegaOut > .
 rl o < {S},Sigma,OmegaIn,OmegaOut > => < S,Sigma,OmegaIn,OmegaOut > .

crl o < X = A ;,Sigma,OmegaIn,OmegaOut > => < X = A' ;,Sigma',OmegaIn',OmegaOut > if o < A,Sigma,OmegaIn > => < A',Sigma',OmegaIn' > .
crl o < X = A ;,Sigma,OmegaIn,OmegaOut > => < halting,Sigma',OmegaIn',OmegaOut > if o < A,Sigma,OmegaIn > => < error ,Sigma',OmegaIn' > .
crl o < X = I ;,Sigma,OmegaIn,OmegaOut > => < {},Sigma[I / X],OmegaIn,OmegaOut > if Sigma(X) =/=Bool undefined .

crl o < S1 S2,Sigma,OmegaIn,OmegaOut > => < S1' S2,Sigma',OmegaIn',OmegaOut' > if o < S1,Sigma,OmegaIn,OmegaOut > => < S1',Sigma',OmegaIn',OmegaOut' > .
crl o < S1 S2,Sigma,OmegaIn,OmegaOut > => <  halting,Sigma',OmegaIn',OmegaOut' > if o < S1,Sigma,OmegaIn,OmegaOut > => < halting,Sigma',OmegaIn',OmegaOut' > .
rl o < {} S2,Sigma,OmegaIn,OmegaOut > => < S2,Sigma,OmegaIn,OmegaOut > .

crl o < if (B) S1 else S2,Sigma,OmegaIn,OmegaOut > => < if (B') S1 else S2,Sigma',OmegaIn',OmegaOut > if o < B,Sigma,OmegaIn > => < B',Sigma',OmegaIn' > .
crl o < if (B) S1 else S2,Sigma,OmegaIn,OmegaOut > => < halting,Sigma',OmegaIn',OmegaOut > if o < B,Sigma,OmegaIn > => < error ,Sigma',OmegaIn' > .
rl o < if  (true) S1 else S2,Sigma,OmegaIn,OmegaOut > => < S1,Sigma,OmegaIn,OmegaOut > .
rl o < if (false) S1 else S2,Sigma,OmegaIn,OmegaOut > => < S2,Sigma,OmegaIn,OmegaOut > .

rl o < while (B) S,Sigma,OmegaIn,OmegaOut > => < if (B) {S while (B) S} else {},Sigma,OmegaIn,OmegaOut > .

*** <new> The rule below is not correct anymore.
*** Since programs are now just statements, we have to initialize
*** the state to empty instead of Xl |-> 0.
---  rl o < int Xl ; S > => < S,(Xl |-> 0) > .
*** </new>
*** <new> Programs are regarded as statements in the initial state
---  rl o < P > => < P, .State > .
*** </new>

*** <new> Added the actual small-step SOS of let
 crl o < let X = A in S,Sigma,OmegaIn,OmegaOut > => < let X = A' in S,Sigma',OmegaIn',OmegaOut > if o < A,Sigma,OmegaIn > => < A',Sigma',OmegaIn' > .
 crl o < let X = A in S,Sigma,OmegaIn,OmegaOut > => < halting,Sigma',OmegaIn',OmegaOut > if o < A,Sigma,OmegaIn > => < error ,Sigma',OmegaIn' > .

 crl o < let X = I in S,Sigma,OmegaIn,OmegaOut > => < let X = Sigma'(X) in S',Sigma'[Sigma(X) / X],OmegaIn',OmegaOut' >
  if o < S,Sigma[I / X],OmegaIn,OmegaOut > => < S',Sigma',OmegaIn',OmegaOut' > .
  rl o < let X = I in {},Sigma,OmegaIn,OmegaOut > => < {},Sigma,OmegaIn,OmegaOut > .
 crl o < let X = I in S,Sigma,OmegaIn,OmegaOut > => < halting,Sigma'[Sigma(X) / X],OmegaIn',OmegaOut' >
  if o < S,Sigma[I / X],OmegaIn,OmegaOut > => < S',Sigma',OmegaIn',OmegaOut' > .
*** </new>

*** <new> The small-step SOS of spawning
  op spawn_ : Stmt -> Stmt [ditto] .
 crl o < spawn S,Sigma, OmegaIn,OmegaOut > => < spawn S',Sigma',OmegaIn',OmegaOut' > if o < S,Sigma,OmegaIn,OmegaOut > => < S',Sigma',OmegaIn',OmegaOut' > .
 crl o < spawn S,Sigma, OmegaIn,OmegaOut > => < halting,Sigma',OmegaIn',OmegaOut' > if o < S,Sigma,OmegaIn,OmegaOut > => < halting,Sigma',OmegaIn',OmegaOut' > .

 crl o < spawn S1 S2,Sigma, OmegaIn,OmegaOut > => < spawn S1 S2',Sigma',OmegaIn',OmegaOut' > if o < S2,Sigma,OmegaIn,OmegaOut > => < S2',Sigma',OmegaIn',OmegaOut' > .
 crl o < spawn S1 S2,Sigma, OmegaIn,OmegaOut > => < halting,Sigma',OmegaIn',OmegaOut' > if o < S2,Sigma,OmegaIn,OmegaOut > => < halting,Sigma',OmegaIn',OmegaOut' > .

  rl o < spawn {},Sigma, OmegaIn,OmegaOut > => < {},Sigma, OmegaIn,OmegaOut > .
--- The following rule is not enough:
---  rl o < spawn S {}, Sigma > => < spawn S, Sigma > .
--- We need the following "structural" equation:
---  eq (S1 S2) S = S1 (S2 S) . NOT NEEDED because its already in the Local variable IMP Syntax DESUGARED
*** </new>

*** <new> Added the actual small-step SOS of input/output
  rl o < read(), Sigma, I : OmegaIn, OmegaOut > => < I, Sigma, OmegaIn, OmegaOut > .
 crl o < print(A);,Sigma,OmegaIn,OmegaOut > => < print(A');,Sigma',OmegaIn',OmegaOut > if o < A,Sigma,OmegaIn > => < A',Sigma',OmegaIn' > .
  rl o < print(I);,Sigma,OmegaIn,OmegaOut > => < {},Sigma,OmegaIn,OmegaOut : I > .
*** </new>

*** <new> Programs are regarded as statements in the initial state
--- rl o < P > => < P, .State, OmegaIn,OmegaOut > .
*** </new>

--- TODO, do we need this or top level? does this not screw up my semantics in composition for example?
*** <new> A new rule is needed to transform the halting configuration into a normal one.
---  rl o < halting,Sigma,OmegaIn,OmegaOut > => < {},Sigma,OmegaIn,OmegaOut > .
*** </new>

endm
